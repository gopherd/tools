package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

var flags struct {
	suffix    string
	eventType string
	eventpkg  string
}

type positionedStruct struct {
	name string
	pos  token.Pos
}

// getPackageStructs 解析包中的所有 Go 文件，提取出带有特定后缀的结构体
func getPackageStructs(suffix string) ([]positionedStruct, error) {
	structs := make(map[string]token.Pos)
	fset := token.NewFileSet()

	err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if strings.HasSuffix(path, ".go") && !strings.HasSuffix(path, "_test.go") {
			node, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
			if err != nil {
				return err
			}

			for _, decl := range node.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok {
					continue
				}
				for _, spec := range genDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}
					if structType, ok := typeSpec.Type.(*ast.StructType); ok {
						if strings.HasSuffix(typeSpec.Name.Name, suffix) {
							structs[typeSpec.Name.Name] = structType.Struct
						}
					}
				}
			}
		}
		return nil
	})

	var sortedStructs = make([]positionedStruct, 0, len(structs))
	for name, pos := range structs {
		sortedStructs = append(sortedStructs, positionedStruct{name: name, pos: pos})
	}
	sort.SliceStable(sortedStructs, func(i, j int) bool {
		si, sj := sortedStructs[i], sortedStructs[j]
		return si.pos < sj.pos || (si.pos == sj.pos && si.name < sj.name)
	})
	return sortedStructs, err
}

// generateCode 生成事件相关的代码
func generateCode(structs []positionedStruct, packageName string) string {
	var sb strings.Builder

	fmt.Fprintf(&sb, `// Code generated by "%s"; DO NOT EDIT.`, strings.Join(os.Args, " "))
	fmt.Fprintf(&sb, "\n\npackage %s\n\n", packageName)

	if len(structs) > 0 {
		sb.WriteString("import (\n")
		sb.WriteString("\t\"context\"\n")
		if flags.eventType == "reflect.Type" {
			sb.WriteString("\t\"reflect\"\n")
		}
		fmt.Fprintf(&sb, "\n\t\"%s\"\n", flags.eventpkg)
		sb.WriteString(")\n")

		if flags.eventType != "reflect.Type" && flags.eventType != "string" {
			// enums
			sb.WriteString("\nconst (\n")
			for i := range structs {
				structName := structs[i].name
				typeName := structName + "Type"
				if i == 0 {
					fmt.Fprintf(&sb, "\t%s %s = iota + 1\n", typeName, flags.eventType)
				} else {
					fmt.Fprintf(&sb, "\t%s\n", typeName)
				}
			}
			sb.WriteString(")\n")
		}
	}

	for i := range structs {
		structName := structs[i].name
		typeName := structName + "Type"
		fmt.Fprintf(&sb, "\n// Generated for %s\n", structName)
		if flags.eventType == "reflect.Type" {
			fmt.Fprintf(&sb, "var %s = reflect.TypeOf((*%s)(nil))\n\n", typeName, structName)
		} else if flags.eventType == "string" {
			fmt.Fprintf(&sb, "const %s = \"%s\"\n\n", typeName, structName)
		}
		fmt.Fprintf(&sb, "func (*%s) Typeof() %s {\n", structName, flags.eventType)
		fmt.Fprintf(&sb, "\treturn %s\n", typeName)
		fmt.Fprintf(&sb, "}\n\n")
		fmt.Fprintf(&sb, "func init() {\n")
		fmt.Fprintf(&sb, "\tevent.Register(new(%s))\n", structName)
		fmt.Fprintf(&sb, "}\n\n")
		fmt.Fprintf(&sb, "func %sListener(h func(context.Context, *%s) error) event.Listener[%s] {\n", structName, structName, flags.eventType)
		fmt.Fprintf(&sb, "\treturn event.Listen(%s, h)\n", typeName)
		fmt.Fprintf(&sb, "}\n")
	}

	return sb.String()
}

// writeToFile 将生成的代码写入文件
func writeToFile(content, packageName string) error {
	fileName := "eventer.gen.go"
	return os.WriteFile(fileName, []byte(content), 0644)
}

func main() {
	flag.StringVar(&flags.suffix, "s", "Event", "Type suffix")
	flag.StringVar(&flags.eventType, "t", "reflect.Type", "Type of event")
	flag.StringVar(&flags.eventpkg, "pkg", "github.com/gopherd/core/event", "External event package")
	flag.Parse()

	pkg, err := build.Default.ImportDir(".", build.IgnoreVendor)
	if err != nil {
		log.Fatalf("Failed to get package info: %v", err)
	}
	packageName := pkg.Name

	structs, err := getPackageStructs(flags.suffix)
	if err != nil {
		log.Fatalf("Failed to get structs: %v", err)
	}

	code := generateCode(structs, packageName)
	err = writeToFile(code, packageName)
	if err != nil {
		log.Fatalf("Failed to write to file: %v", err)
	}
}
