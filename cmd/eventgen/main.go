package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

var flags struct {
	suffix   string
	eventpkg string
}

type positionedStruct struct {
	name string
	pos  token.Pos
}

// getPackageStructs 解析包中的所有 Go 文件，提取出带有特定后缀的结构体
func getPackageStructs(suffix string) ([]positionedStruct, error) {
	structs := make(map[string]token.Pos)
	fset := token.NewFileSet()

	err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if strings.HasSuffix(path, ".go") && !strings.HasSuffix(path, "_test.go") {
			node, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
			if err != nil {
				return err
			}

			for _, decl := range node.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok {
					continue
				}
				for _, spec := range genDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}
					if structType, ok := typeSpec.Type.(*ast.StructType); ok {
						if strings.HasSuffix(typeSpec.Name.Name, suffix) {
							structs[typeSpec.Name.Name] = structType.Struct
						}
					}
				}
			}
		}
		return nil
	})

	var sortedStructs = make([]positionedStruct, 0, len(structs))
	for name, pos := range structs {
		sortedStructs = append(sortedStructs, positionedStruct{name: name, pos: pos})
	}
	sort.SliceStable(sortedStructs, func(i, j int) bool {
		si, sj := sortedStructs[i], sortedStructs[j]
		return si.pos < sj.pos || (si.pos == sj.pos && si.name < sj.name)
	})
	return sortedStructs, err
}

// generateCode 生成事件相关的代码
func generateCode(structs []positionedStruct, packageName string) string {
	var builder strings.Builder

	fmt.Fprintf(&builder, `// Code generated by "%s"; DO NOT EDIT.`, strings.Join(os.Args, " "))
	builder.WriteString("\n\npackage " + packageName + "\n\n")

	if len(structs) > 0 {
		builder.WriteString("import (\n")
		builder.WriteString("\t\"reflect\"\n\n")
		fmt.Fprintf(&builder, "\t\"%s\"\n", flags.eventpkg)
		builder.WriteString(")\n\n")
	}

	for i := range structs {
		structName := structs[i].name
		typeName := structName + "Type"
		builder.WriteString(fmt.Sprintf("var %s = reflect.TypeOf((*%s)(nil))\n\n", typeName, structName))
		builder.WriteString(fmt.Sprintf("func (e *%s) Typeof() reflect.Type {\n", structName))
		builder.WriteString(fmt.Sprintf("\treturn %s\n", typeName))
		builder.WriteString("}\n\n")
		builder.WriteString(fmt.Sprintf("func %sListener(h func(*%s)) event.Listener[reflect.Type] {\n", structName, structName))
		builder.WriteString(fmt.Sprintf("\treturn event.Listen(%s, h)\n", typeName))
		builder.WriteString("}\n\n")
	}

	return builder.String()
}

// writeToFile 将生成的代码写入文件
func writeToFile(content, packageName string) error {
	fileName := packageName + ".eventgen.go"
	return os.WriteFile(fileName, []byte(content), 0644)
}

func main() {
	flag.StringVar(&flags.suffix, "suffix", "Event", "Type suffix")
	flag.StringVar(&flags.eventpkg, "eventpkg", "github.com/gopherd/core/event", "External event package")
	flag.Parse()

	pkg, err := build.Default.ImportDir(".", build.IgnoreVendor)
	if err != nil {
		log.Fatalf("Failed to get package info: %v", err)
	}
	packageName := pkg.Name

	structs, err := getPackageStructs(flags.suffix)
	if err != nil {
		log.Fatalf("Failed to get structs: %v", err)
	}

	code := generateCode(structs, packageName)
	err = writeToFile(code, packageName)
	if err != nil {
		log.Fatalf("Failed to write to file: %v", err)
	}
}
