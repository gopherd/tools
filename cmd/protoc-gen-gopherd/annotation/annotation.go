package annotation

import (
	"errors"
	"fmt"
	"strings"
	"text/scanner"
	"unicode"

	"github.com/gopherd/doge/encoding"
	"github.com/gopherd/doge/text/fuzzy"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"

	"github.com/gopherd/tools/cmd/protoc-gen-gopherd/context"
)

// Annotation interface
type Annotation interface {
	Name() string
}

type Repeatable interface {
	Repeatable()
}

const (
	AnnotationType = "Type"
)

var allAnnotationTypes = []string{
	AnnotationType,
}

func findSimilarAnnotationTypes(src string) []string {
	var found []string
	for _, dst := range allAnnotationTypes {
		if fuzzy.Match(dst, src, 0.5) {
			found = append(found, dst)
		}
	}
	return found
}

// Generate generates code for annotations
func Generate(ctx *context.Context, gen *protogen.Plugin, f *protogen.File) error {
	var (
		annotations = make(map[string][]*associatedAnnotation)
		errors      []error
		associated  associated
	)
	associated.file = f

	associated.oneof.pkg = true
	leadingComments := findPackageLeadingComments(gen, f)
	for _, comments := range leadingComments {
		associated.lineno = comments.lineno
		if err := parseAnnotations(associated, annotations, string(comments.comments)); err != nil {
			errors = append(errors, err)
		}
	}

	associated.reset()
	for _, m := range f.Messages {
		lineno := getLineno(gen, f, m.Location)
		associated.oneof.message = m
		associated.lineno = lineno
		if err := parseAnnotations(associated, annotations, string(m.Comments.Leading)); err != nil {
			errors = append(errors, err)
		}
	}

	associated.reset()
	for _, m := range f.Enums {
		lineno := getLineno(gen, f, m.Location)
		associated.oneof.enum = m
		associated.lineno = lineno
		if err := parseAnnotations(associated, annotations, string(m.Comments.Leading)); err != nil {
			errors = append(errors, err)
		}
	}
	if len(errors) > 0 {
		errorCnt := 0
		for _, err := range errors {
			if isWarning(err) {
				println("gopherd: Warning: " + err.Error())
			} else {
				println("gopherd: " + err.Error())
				errorCnt++
			}
		}
		if errorCnt > 0 {
			return nil
		}
	}
	if len(annotations) == 0 {
		return nil
	}
	outputFilename := f.GeneratedFilenamePrefix + ".gopherd.go"
	g := gen.NewGeneratedFile(outputFilename, f.GoImportPath)
	g.P("// Code generated by protoc-gen-gopherd. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P("package ", f.GoPackageName)
	g.P()
	if ctx.Type.TypeRegistry != "" {
		g.P("import registry ", `"`, ctx.Type.TypeRegistry, `"`)
	}
	g.P("import proto ", `"`, ctx.ProtobufPkg, `"`)
	g.P()
	g.P("var _ = proto.Marshal")
	for name, anns := range annotations {
		if name == AnnotationType {
			if err := generateTypeAnnotation(ctx, gen, f, g, anns); err != nil {
				println("gopherd: " + err.Error())
			}
		}
	}

	return nil
}

type packageLeadingComments struct {
	comments protogen.Comments
	lineno   int
}

func findPackageLeadingComments(gen *protogen.Plugin, f *protogen.File) []packageLeadingComments {
	const (
		packageFieldNumber = 2
	)
	var comments []packageLeadingComments
	for _, loc := range f.Proto.SourceCodeInfo.Location {
		if len(loc.Path) == 0 {
			continue
		}
		if loc.LeadingComments == nil || *loc.LeadingComments == "" {
			continue
		}
		if loc.Path[0] == packageFieldNumber {
			comments = append(comments, packageLeadingComments{
				comments: protogen.Comments(*loc.LeadingComments),
				lineno:   int(loc.Span[0]),
			})
		}
	}
	return comments
}

func getLineno(gen *protogen.Plugin, file *protogen.File, location protogen.Location) int {
	for _, loc := range file.Proto.SourceCodeInfo.Location {
		if location.Path.Equal(protoreflect.SourcePath(loc.Path)) {
			return int(loc.Span[0])
		}
	}
	return 0
}

type warning struct {
	text string
}

func warn(text string) *warning { return &warning{text: text} }

func (w *warning) Error() string {
	return w.text
}

func isWarning(err error) bool {
	_, ok := err.(*warning)
	return ok
}

func parseAnnotations(
	associated associated,
	annotations map[string][]*associatedAnnotation,
	comment string,
) error {
	lines := strings.Split(strings.TrimSuffix(comment, "\n"), "\n")
	associated.lineno -= len(lines)
	seen := make(map[string]Annotation)
	for _, line := range lines {
		if ann, err := parseAnnotation(associated, strings.TrimSpace(line)); err != nil {
			return err
		} else if ann != nil {
			if _, ok := seen[ann.Name()]; ok {
				if _, ok := ann.(Repeatable); !ok {
					return associated.errorf("@%s annotation duplicated", ann.Name())
				}
			}
			seen[ann.Name()] = ann
			annotations[ann.Name()] = append(annotations[ann.Name()], newAssociatedAnnotation(associated, ann))
		}
		associated.lineno++
	}
	return nil
}

type associatedAnnotation struct {
	annotation Annotation
	associated associated
}

type associated struct {
	file   *protogen.File
	lineno int
	oneof  struct {
		pkg     bool
		message *protogen.Message
		enum    *protogen.Enum
	}
}

func newAssociatedAnnotation(associated associated, ann Annotation) *associatedAnnotation {
	return &associatedAnnotation{
		annotation: ann,
		associated: associated,
	}
}

func (associated *associated) reset() {
	associated.oneof.pkg = false
	associated.oneof.message = nil
	associated.oneof.enum = nil
}

func (associated *associated) filename() string {
	return associated.file.Desc.Path()
}

func (associated *associated) errorf(format string, args ...interface{}) error {
	prefix := fmt.Sprintf("%s:%d: ", associated.filename(), associated.lineno+1)
	return errors.New(prefix + fmt.Sprintf(format, args...))
}

func parseAnnotation(associated associated, src string) (ann Annotation, err error) {
	if len(src) < 2 || src[0] != '@' {
		// not an annotation
		return
	}
	var (
		name string
		off  int
	)
	if off = strings.Index(src, "("); off < 0 {
		off = len(src)
	}
	name = strings.TrimSpace(src[1:off])
	src = src[off:]
	if !isIdent(name) {
		// not an annotation
		return
	}

	const commentLeadingSize = 3 // sizeof("// ")
	var (
		parser  encoding.Parser
		s       scanner.Scanner
		skipped = strings.Repeat("\n", associated.lineno) + strings.Repeat(" ", off+commentLeadingSize)
	)
	s.Init(strings.NewReader(skipped + src))
	s.Mode = scanner.ScanIdents | scanner.ScanFloats | scanner.ScanChars | scanner.ScanStrings
	s.Position.Filename = associated.filename()
	parser.Init(&s)

	switch name {
	case AnnotationType:
		return parseTypeAnnotation(associated, &parser)
	default:
		// unknown annotation type
		found := findSimilarAnnotationTypes(name)
		if len(found) > 0 {
			parser.Next()
			pos := parser.BeginPos()
			pos.Column = commentLeadingSize
			for i := range found {
				found[i] = "@" + found[i]
			}
			err = warn(fmt.Sprintf("%s: unknown annotation @%s, did you mean: %s?", pos, name, strings.Join(found, ",")))
		}
		return
	}
}

func isIdent(s string) bool {
	if len(s) == 0 {
		return false
	}
	for i, c := range s {
		if !isIdentRune(c, i) {
			return false
		}
	}
	return true
}

func isIdentRune(ch rune, i int) bool {
	return ch == '_' || unicode.IsLetter(ch) || unicode.IsDigit(ch) && i > 0
}
